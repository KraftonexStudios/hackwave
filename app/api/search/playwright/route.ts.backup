import { NextRequest, NextResponse } from "next/server";
import { chromium } from "playwright";

interface SearchResult {
  title: string;
  url: string;
  snippet: string;
  source: string;
}

// Generate mock search results as fallback
function generateMockSearchResults(query: string) {
  const mockResults: SearchResult[] = [
    {
      title: `${query} - Comprehensive Guide and Overview`,
      url: `https://example.com/${query.replace(/\s+/g, "-").toLowerCase()}`,
      snippet: `Learn everything about ${query}. This comprehensive guide covers the fundamentals, best practices, and advanced techniques related to ${query}.`,
      source: "example.com",
    },
    {
      title: `Top 10 ${query} Tools and Resources`,
      url: `https://tools.example.com/${query
        .replace(/\s+/g, "-")
        .toLowerCase()}`,
      snippet: `Discover the best tools and resources for ${query}. Our curated list includes both free and premium options to help you get started.`,
      source: "tools.example.com",
    },
    {
      title: `${query} Tutorial for Beginners`,
      url: `https://tutorial.example.com/${query
        .replace(/\s+/g, "-")
        .toLowerCase()}`,
      snippet: `Step-by-step tutorial covering ${query} from basics to advanced concepts. Perfect for beginners and intermediate users.`,
      source: "tutorial.example.com",
    },
    {
      title: `Latest ${query} News and Updates`,
      url: `https://news.example.com/${query
        .replace(/\s+/g, "-")
        .toLowerCase()}`,
      snippet: `Stay updated with the latest news, trends, and developments in ${query}. Get insights from industry experts and thought leaders.`,
      source: "news.example.com",
    },
    {
      title: `${query} Community and Discussion Forum`,
      url: `https://forum.example.com/${query
        .replace(/\s+/g, "-")
        .toLowerCase()}`,
      snippet: `Join the ${query} community to discuss, share experiences, and get help from fellow enthusiasts and professionals.`,
      source: "forum.example.com",
    },
  ];

  const processingTime = 1500 + Math.random() * 1000; // Simulate processing time

  return {
    success: true,
    results: mockResults,
    totalResults: mockResults.length,
    processingTime: Math.round(processingTime),
    query,
    timestamp: new Date().toISOString(),
    source: "mock-fallback",
  };
}

// Reusable function for search engine logic
export async function performWebSearch(query: string) {
  let browser: any = null;

  try {
    if (!query || typeof query !== "string") {
      throw new Error("Query parameter is required");
    }

    const startTime = Date.now();
    console.log("üöÄ Starting web search for query:", query);

    // Launch browser with stealth settings
    browser = await chromium.launch({
      headless: true,
      args: [
        "--no-sandbox",
        "--disable-setuid-sandbox",
        "--disable-dev-shm-usage",
        "--disable-accelerated-2d-canvas",
        "--no-first-run",
        "--no-zygote",
        "--disable-gpu",
      ],
    });

    const context = await browser.newContext({
      viewport: { width: 1920, height: 1080 },
      userAgent:
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
      extraHTTPHeaders: {
        Accept:
          "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate",
        DNT: "1",
        Connection: "keep-alive",
        "Upgrade-Insecure-Requests": "1",
      },
    });

    const page = await context.newPage();

    // Try multiple search engines as fallback
    const searchEngines = [
      {
        name: "Yandex",
        url: `https://yandex.com/search/?text=${encodeURIComponent(
          query
        )}&lr=10418`,
        selectors: [
          ".organic__url",
          ".organic__title-wrapper a",
          ".serp-item__title-link",
          ".organic .link",
          ".serp-item .link",
          "h2 a",
          "a[href*='http']:not([href*='yandex'])",
        ],
      },
      {
        name: "Startpage",
        url: `https://www.startpage.com/sp/search?query=${encodeURIComponent(
          query
        )}`,
        selectors: [
          ".w-gl__result-title",
          ".result-title a",
          "h3 a",
          ".result a",
          "a[href*='http']:not([href*='startpage.com'])",
        ],
      },
      {
        name: "DuckDuckGo",
        url: `https://duckduckgo.com/html/?q=${encodeURIComponent(query)}`,
        selectors: [
          "[data-testid='result-title-a']",
          ".result__title a",
          "h3 a",
          "[data-testid='result'] a",
          ".result__a",
          "h2.result__title a",
          ".result-title a",
          "a[href*='http']:not([href*='duckduckgo.com'])",
        ],
      },
      {
        name: "Bing",
        url: `https://www.bing.com/search?q=${encodeURIComponent(query)}`,
        selectors: [".b_title a", "h2 a", ".b_algo h2 a", "[data-bm] a"],
      },
      {
        name: "SearX",
        url: `https://searx.be/search?q=${encodeURIComponent(
          query
        )}&format=html`,
        selectors: [
          ".result h3 a",
          ".result-title a",
          ".result .url a",
          "h3 a",
          "a[href*='http']:not([href*='searx'])",
        ],
      },
    ];

    let searchSuccess = false;
    let searchResults = [];

    for (const engine of searchEngines) {
      try {
        console.log(`üîç Trying ${engine.name}: ${engine.url}`);

        // Reduced delay for faster performance
        await page.waitForTimeout(500);

        await page.goto(engine.url, {
          waitUntil: "domcontentloaded", // Faster than networkidle
          timeout: 15000, // Reduced from 30s to 15s
        });

        // Reduced content loading delay
        await page.waitForTimeout(2000);

        // Check if we're being blocked or redirected
        const currentUrl = page.url();
        console.log(`üìç Current URL after navigation: ${currentUrl}`);

        // Check for CAPTCHA or blocking messages
        const captchaExists = await page
          .locator('input[name="captcha"], .captcha, [id*="captcha"]')
          .count();
        if (captchaExists > 0) {
          console.log(
            `üö´ CAPTCHA detected on ${engine.name}, trying next engine`
          );
          continue;
        }

        // Wait for search results to actually load (reduced timeout)
        console.log(`‚è≥ Waiting for ${engine.name} search results to load...`);
        try {
          await page.waitForSelector(engine.selectors.join(", "), {
            timeout: 5000,
          }); // Reduced from 10s to 5s
          console.log(`‚úÖ ${engine.name} search results loaded successfully`);
        } catch (waitError) {
          console.log(
            `‚ö†Ô∏è Timeout waiting for ${engine.name} selectors, proceeding anyway...`
          );
        }

        // Check page title and content
        const pageTitle = await page.title();
        console.log(`üìÑ Page title: ${pageTitle}`);

        // Try to find search results using multiple selectors
        let selectorFound = false;
        for (const selector of engine.selectors) {
          try {
            const elementCount = await page.locator(selector).count();
            console.log(
              `üéØ Selector "${selector}" found ${elementCount} elements`
            );
            if (elementCount > 0) {
              console.log(`‚úÖ Found elements with selector: ${selector}`);
              selectorFound = true;
              break;
            }
          } catch (error) {
            console.log(`‚ùå Selector failed: ${selector}`, error);
            continue;
          }
        }

        if (!selectorFound) {
          console.log(
            `üö´ No search result selectors found on ${engine.name}, trying next engine`
          );
          continue;
        }

        console.log(`‚úÖ ${engine.name} page loaded successfully`);
        searchSuccess = true;
        break;
      } catch (engineError) {
        console.error(`‚ùå ${engine.name} failed:`, engineError);
        continue;
      }
    }

    if (!searchSuccess) {
      // Take a screenshot for debugging
      console.log("üì∏ Taking screenshot for debugging...");
      await page.screenshot({ path: "debug-search-page.png", fullPage: true });

      // Get page content for debugging
      const bodyText = await page.locator("body").textContent();
      console.log(
        "üìÑ Page body text (first 500 chars):",
        bodyText?.substring(0, 500)
      );

      // Get HTML structure for debugging
      const htmlContent = await page.content();
      console.log(
        "üîç HTML structure (first 1000 chars):",
        htmlContent.substring(0, 1000)
      );

      // Check for any elements that might contain results
      const allLinks = await page.locator("a").count();
      const allDivs = await page.locator("div").count();
      const allH3s = await page.locator("h3").count();
      console.log(
        `üìä Page elements: ${allLinks} links, ${allDivs} divs, ${allH3s} h3s`
      );

      // Try to find any elements with 'result' in class or id
      const resultElements = await page
        .locator('[class*="result"], [id*="result"]')
        .count();
      console.log(`üéØ Elements with 'result' in class/id: ${resultElements}`);

      console.log("üö´ All search engines failed, falling back to mock results");
      return generateMockSearchResults(query);
    }

    // Extract search results with improved error handling using Playwright
    console.log("üìä Extracting search results from page...");
    const results: SearchResult[] = [];

    try {
      // Use Playwright's locator API with current search engine selectors
      const currentEngine =
        searchEngines.find((engine) => searchSuccess) || searchEngines[0];
      const searchResultElements = await page
        .locator(currentEngine.selectors.join(", "))
        .all();
      console.log(
        "Found",
        searchResultElements.length,
        "result elements on page"
      );

      // Process only top 5 results for faster performance
      for (let i = 0; i < Math.min(searchResultElements.length, 5); i++) {
        try {
          const titleElement = searchResultElements[i];
          const title = await titleElement.textContent();

          if (!title) continue;

          // For DuckDuckGo, the element might already be a link
          let linkElement = titleElement;
          let url = await titleElement.getAttribute("href");

          // If not a direct link, find the parent link element
          if (!url) {
            linkElement = await titleElement
              .locator("xpath=ancestor::a")
              .first();
            url = await linkElement.getAttribute("href");
          }

          if (!url || !url.startsWith("http")) continue;

          // Find snippet text - target the specific result container
          let snippet = "";
          try {
            // Get the immediate parent result container
            const resultContainer = await linkElement
              .locator(
                "xpath=ancestor::div[contains(@class, 'result') or contains(@class, 'results_links') or contains(@class, 'b_algo')]"
              )
              .first();

            // Try to find snippet in the same result container
            const snippetSelectors = [
              // Yandex selectors
              ".organic__text", // Yandex organic result text
              ".serp-item__text", // Yandex SERP item text
              ".organic__content-wrapper .text", // Yandex content wrapper
              ".snippet-text", // Yandex snippet text
              // Startpage selectors
              ".w-gl__description", // Startpage description
              ".result-desc", // Startpage result description
              ".search-result__body", // Startpage result body
              // DuckDuckGo selectors
              "[data-testid='result-snippet']", // Modern DuckDuckGo snippet
              ".result__snippet", // Classic DuckDuckGo snippet class
              ".result__body", // DuckDuckGo body class
              "[data-testid='result-extras']", // Modern DuckDuckGo extras
              // Bing selectors
              ".b_caption p", // Bing snippet
              ".b_caption", // Bing caption
              // SearX selectors
              ".result .content", // SearX result content
              ".result p", // SearX result paragraph
              ".result-content", // SearX result content class
              // Generic selectors
              ".snippet", // Generic snippet class
              ".result-snippet", // Alternative snippet class
              ".description", // Generic description class
              "span:not(:has(a)):not(:has(h1)):not(:has(h2)):not(:has(h3))", // Spans without links or headers
            ];

            for (const selector of snippetSelectors) {
              try {
                const snippetElements = await resultContainer
                  .locator(selector)
                  .all();
                for (const element of snippetElements) {
                  const text = await element.textContent();
                  if (
                    text &&
                    text.length > 30 &&
                    text.length < 300 &&
                    !text.includes(title) &&
                    !text.includes(url) &&
                    !text.toLowerCase().includes("sign up") &&
                    !text.toLowerCase().includes("learn more") &&
                    !text.includes("...")
                  ) {
                    snippet = text.replace(/\s+/g, " ").trim();
                    break;
                  }
                }
                if (snippet) break;
              } catch {
                continue;
              }
            }

            // Fallback: extract from the result container text
            if (!snippet) {
              const allText = await resultContainer.textContent();
              if (allText) {
                // Split by common separators and find descriptive text
                const parts = allText
                  .split(/[\n\r]/)
                  .filter(
                    (part) =>
                      part.trim().length > 30 &&
                      part.trim().length < 300 &&
                      !part.includes(title) &&
                      !part.includes(url) &&
                      !part.toLowerCase().includes("sign up") &&
                      !part.toLowerCase().includes("learn more")
                  );

                snippet = parts[0]
                  ? parts[0].replace(/\s+/g, " ").trim()
                  : "No description available";
              }
            }
          } catch {
            snippet = "No description available";
          }

          try {
            const domain = new URL(url).hostname.replace("www.", "");
            const result = {
              title: title.trim(),
              url,
              snippet: snippet.substring(0, 200),
              source: domain,
            };

            console.log(`Result ${i + 1}:`, {
              title: title.substring(0, 50) + "...",
              source: domain,
              snippetLength: snippet.length,
            });

            results.push(result);
          } catch (e) {
            console.log(`Skipping result ${i + 1} due to invalid URL:`, url);
          }
        } catch (elementError) {
          console.log(`Error processing result ${i + 1}:`, elementError);
        }
      }
    } catch (evaluationError) {
      console.error("‚ùå Error during page evaluation:", evaluationError);
      throw new Error(
        `Failed to extract search results: ${
          evaluationError instanceof Error
            ? evaluationError.message
            : "Unknown evaluation error"
        }`
      );
    }

    console.log("üìà Raw results extracted:", results.length, "items");
    console.log(
      "üìã Raw results summary:",
      results.map((r, i) => ({
        index: i + 1,
        title: r.title.substring(0, 30) + "...",
        source: r.source,
        hasSnippet: !!r.snippet,
      }))
    );

    const processingTime = Date.now() - startTime;

    // Filter and clean results
    console.log("üßπ Filtering and cleaning results...");
    const cleanResults = results
      .filter((result) => result.title && result.url && result.source)
      .slice(0, 5); // Top 5 results

    console.log("‚ú® Final cleaned results:", cleanResults.length, "items");
    console.log(
      "üìä Final results data:",
      cleanResults.map((r, i) => ({
        index: i + 1,
        title: r.title,
        source: r.source,
        url: r.url.substring(0, 50) + "...",
        snippetLength: r.snippet.length,
      }))
    );
    console.log("‚è±Ô∏è Total processing time:", processingTime, "ms");

    return {
      success: true,
      results: cleanResults,
      query,
      totalResults: cleanResults.length,
      processingTime,
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    console.error("‚ùå Playwright search error for query:", query || "unknown");
    console.error("üîç Error details:", {
      message: error instanceof Error ? error.message : "Unknown error",
      stack: error instanceof Error ? error.stack : undefined,
      timestamp: new Date().toISOString(),
    });

    // Fallback to mock search results when web scraping fails
    console.log("üîÑ Falling back to mock search results for query:", query);
    return generateMockSearchResults(query);
  } finally {
    // Always close browser to prevent memory leaks
    if (browser) {
      try {
        await browser.close();
        console.log("üîí Browser closed successfully");
      } catch (closeError) {
        console.error("‚ö†Ô∏è Error closing browser:", closeError);
      }
    }
  }
}

export async function POST(request: NextRequest) {
  try {
    const requestBody = await request.json();
    const query = requestBody.query;

    if (!query || typeof query !== "string") {
      return NextResponse.json(
        { error: "Query parameter is required" },
        { status: 400 }
      );
    }

    const searchData = await performWebSearch(query);
    return NextResponse.json(searchData);
  } catch (error) {
    console.error("‚ùå Search API error:", error);
    return NextResponse.json(
      {
        success: false,
        error: "Failed to perform web search",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 }
    );
  }
}

// Handle OPTIONS for CORS
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type",
    },
  });
}
